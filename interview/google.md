1. binary trees, n-ary trees, and trie-trees

2. red/black tree, a splay tree or an AVL tree

3. represent a graph in memory (objects and pointers, matrix, and adjacency list, pros and cons

4. inorder, postorder and preorder traversal (for trees). You should know their computational complexity, their tradeoffs, and how to implement them in real code.

5. NP-complete problems, such as traveling salesman and the knapsack problem

6. processes, threads, and concurrency issues

7. locks,mutexes, semaphores and monitors

8. deadlock and livelock and how to avoid them

9. resources a processes needs, a thread needs, how context switching works, and how it's initiated by the operating system and underlying hardware

10. scheduling. The world is rapidly moving towards multi-core, so know the fundamentals of "modern" concurrency constructs.

11. counting problems, probability problems, and other Discrete Math 101 situations

12. n-choose-k problems and their ilk

13. Sample topics: biggest challenges faced, best/worst designs seen, performance analysis and optimization, testing and ideas for improving existing products.

14. finally, ask to interviewer some questions about google
one day in google, timeline
技术上走过的弯路，浪费时间，怎么看？
程序员成长路线，35岁以后怎么办，感觉很恐惧
